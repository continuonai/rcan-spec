---
interface Props {
  urdfUrl: string;
  robotName: string;
}

const { urdfUrl, robotName } = Astro.props;
---

<div class="urdf-viewer-container" data-urdf-url={urdfUrl} data-robot-name={robotName}>
  <div class="viewer-header">
    <h3>3D Model Viewer</h3>
    <div class="viewer-controls">
      <button class="control-btn" id="reset-camera" title="Reset Camera">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
          <path d="M3 3v5h5"/>
        </svg>
      </button>
      <button class="control-btn" id="toggle-wireframe" title="Toggle Wireframe">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M12 2L2 7l10 5 10-5-10-5z"/>
          <path d="M2 17l10 5 10-5"/>
          <path d="M2 12l10 5 10-5"/>
        </svg>
      </button>
      <button class="control-btn" id="toggle-grid" title="Toggle Grid">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
          <line x1="3" y1="9" x2="21" y2="9"/>
          <line x1="3" y1="15" x2="21" y2="15"/>
          <line x1="9" y1="3" x2="9" y2="21"/>
          <line x1="15" y1="3" x2="15" y2="21"/>
        </svg>
      </button>
      <button class="control-btn" id="fullscreen-btn" title="Fullscreen">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
        </svg>
      </button>
    </div>
  </div>
  <div class="viewer-canvas-wrapper">
    <canvas id="urdf-canvas"></canvas>
    <div class="loading-overlay" id="loading-overlay">
      <div class="loader"></div>
      <p>Loading 3D model...</p>
    </div>
    <div class="error-overlay" id="error-overlay" style="display: none;">
      <p class="error-message"></p>
      <p class="error-hint">URDF files often require external mesh files that may not be accessible due to CORS restrictions.</p>
      <a href={urdfUrl} target="_blank" rel="noopener noreferrer" class="view-source-btn">View URDF Source</a>
    </div>
  </div>
  <div class="viewer-footer">
    <p>Click and drag to rotate. Scroll to zoom. Right-click to pan.</p>
    <a href={urdfUrl} target="_blank" rel="noopener noreferrer">View URDF source</a>
  </div>
</div>

<script>
  import * as THREE from 'three';
  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

  class URDFViewerController {
    private container: HTMLElement;
    private canvas: HTMLCanvasElement;
    private scene: THREE.Scene;
    private camera: THREE.PerspectiveCamera;
    private renderer: THREE.WebGLRenderer;
    private controls: OrbitControls;
    private gridHelper: THREE.GridHelper;
    private robot: THREE.Group;
    private wireframeMode: boolean = false;
    private showGrid: boolean = true;

    constructor(container: HTMLElement) {
      this.container = container;
      this.canvas = container.querySelector('#urdf-canvas') as HTMLCanvasElement;

      this.init();
      this.createPlaceholderRobot();
      this.setupEventListeners();
      this.animate();
      this.hideLoading();
    }

    private init() {
      // Scene
      this.scene = new THREE.Scene();
      this.scene.background = new THREE.Color(0x0a0a0f);

      // Camera
      const wrapper = this.canvas.parentElement!;
      const aspect = wrapper.clientWidth / wrapper.clientHeight;
      this.camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000);
      this.camera.position.set(3, 2, 3);

      // Renderer
      this.renderer = new THREE.WebGLRenderer({
        canvas: this.canvas,
        antialias: true
      });
      this.renderer.setSize(wrapper.clientWidth, wrapper.clientHeight);
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      this.renderer.shadowMap.enabled = true;
      this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // Controls
      this.controls = new OrbitControls(this.camera, this.canvas);
      this.controls.enableDamping = true;
      this.controls.dampingFactor = 0.05;
      this.controls.minDistance = 1;
      this.controls.maxDistance = 20;

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      this.scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 10, 7.5);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 1024;
      directionalLight.shadow.mapSize.height = 1024;
      this.scene.add(directionalLight);

      const fillLight = new THREE.DirectionalLight(0x22d3ee, 0.3);
      fillLight.position.set(-5, 3, -5);
      this.scene.add(fillLight);

      // Grid
      this.gridHelper = new THREE.GridHelper(10, 20, 0x27272a, 0x1a1a1f);
      this.scene.add(this.gridHelper);

      // Axes helper (small)
      const axesHelper = new THREE.AxesHelper(0.5);
      axesHelper.position.set(-4.5, 0.01, -4.5);
      this.scene.add(axesHelper);

      // Handle resize
      window.addEventListener('resize', () => this.onResize());
    }

    private createPlaceholderRobot() {
      this.robot = new THREE.Group();

      // Base
      const baseGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.2, 32);
      const baseMaterial = new THREE.MeshStandardMaterial({
        color: 0x22d3ee,
        metalness: 0.3,
        roughness: 0.7
      });
      const base = new THREE.Mesh(baseGeometry, baseMaterial);
      base.position.y = 0.1;
      base.castShadow = true;
      base.receiveShadow = true;
      this.robot.add(base);

      // Body
      const bodyGeometry = new THREE.BoxGeometry(0.3, 0.4, 0.3);
      const bodyMaterial = new THREE.MeshStandardMaterial({
        color: 0x3b82f6,
        metalness: 0.4,
        roughness: 0.6
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.position.y = 0.4;
      body.castShadow = true;
      this.robot.add(body);

      // Head
      const headGeometry = new THREE.SphereGeometry(0.15, 32, 32);
      const headMaterial = new THREE.MeshStandardMaterial({
        color: 0x8b5cf6,
        metalness: 0.5,
        roughness: 0.5
      });
      const head = new THREE.Mesh(headGeometry, headMaterial);
      head.position.y = 0.75;
      head.castShadow = true;
      this.robot.add(head);

      // Eyes
      const eyeGeometry = new THREE.SphereGeometry(0.03, 16, 16);
      const eyeMaterial = new THREE.MeshStandardMaterial({
        color: 0x22d3ee,
        emissive: 0x22d3ee,
        emissiveIntensity: 0.5
      });

      const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      leftEye.position.set(-0.05, 0.78, 0.12);
      this.robot.add(leftEye);

      const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      rightEye.position.set(0.05, 0.78, 0.12);
      this.robot.add(rightEye);

      // Wheels
      const wheelGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.08, 32);
      const wheelMaterial = new THREE.MeshStandardMaterial({
        color: 0x27272a,
        metalness: 0.8,
        roughness: 0.3
      });

      const leftWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
      leftWheel.rotation.z = Math.PI / 2;
      leftWheel.position.set(-0.5, 0.15, 0);
      leftWheel.castShadow = true;
      this.robot.add(leftWheel);

      const rightWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
      rightWheel.rotation.z = Math.PI / 2;
      rightWheel.position.set(0.5, 0.15, 0);
      rightWheel.castShadow = true;
      this.robot.add(rightWheel);

      // Ground plane for shadows
      const groundGeometry = new THREE.PlaneGeometry(10, 10);
      const groundMaterial = new THREE.ShadowMaterial({ opacity: 0.3 });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      this.scene.add(ground);

      this.scene.add(this.robot);
    }

    private setupEventListeners() {
      const resetBtn = this.container.querySelector('#reset-camera');
      const wireframeBtn = this.container.querySelector('#toggle-wireframe');
      const gridBtn = this.container.querySelector('#toggle-grid');
      const fullscreenBtn = this.container.querySelector('#fullscreen-btn');

      resetBtn?.addEventListener('click', () => this.resetCamera());
      wireframeBtn?.addEventListener('click', () => this.toggleWireframe());
      gridBtn?.addEventListener('click', () => this.toggleGrid());
      fullscreenBtn?.addEventListener('click', () => this.toggleFullscreen());
    }

    private resetCamera() {
      this.camera.position.set(3, 2, 3);
      this.controls.target.set(0, 0.4, 0);
      this.controls.update();
    }

    private toggleWireframe() {
      this.wireframeMode = !this.wireframeMode;
      this.robot.traverse((child) => {
        if (child instanceof THREE.Mesh) {
          (child.material as THREE.MeshStandardMaterial).wireframe = this.wireframeMode;
        }
      });
    }

    private toggleGrid() {
      this.showGrid = !this.showGrid;
      this.gridHelper.visible = this.showGrid;
    }

    private toggleFullscreen() {
      if (!document.fullscreenElement) {
        this.container.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    }

    private hideLoading() {
      const overlay = this.container.querySelector('#loading-overlay') as HTMLElement;
      if (overlay) {
        overlay.style.display = 'none';
      }
    }

    private onResize() {
      const wrapper = this.canvas.parentElement!;
      const width = wrapper.clientWidth;
      const height = wrapper.clientHeight;

      this.camera.aspect = width / height;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(width, height);
    }

    private animate = () => {
      requestAnimationFrame(this.animate);

      // Gentle rotation of the robot
      if (this.robot) {
        this.robot.rotation.y += 0.002;
      }

      this.controls.update();
      this.renderer.render(this.scene, this.camera);
    };
  }

  // Initialize viewer when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    const container = document.querySelector('.urdf-viewer-container') as HTMLElement;
    if (container) {
      new URDFViewerController(container);
    }
  });
</script>

<style>
  .urdf-viewer-container {
    background: var(--color-bg-alt);
    border: 1px solid var(--color-border);
    border-radius: 12px;
    overflow: hidden;
  }

  .viewer-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 1rem;
    border-bottom: 1px solid var(--color-border);
  }

  .viewer-header h3 {
    margin: 0;
    font-size: 0.9rem;
    font-weight: 600;
  }

  .viewer-controls {
    display: flex;
    gap: 0.5rem;
  }

  .control-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: 6px;
    color: var(--color-text-muted);
    cursor: pointer;
    transition: all 0.2s;
  }

  .control-btn:hover {
    border-color: var(--color-accent);
    color: var(--color-accent);
  }

  .viewer-canvas-wrapper {
    position: relative;
    height: 400px;
  }

  #urdf-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }

  .loading-overlay,
  .error-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(10, 10, 15, 0.9);
    color: var(--color-text-muted);
  }

  .loader {
    width: 40px;
    height: 40px;
    border: 3px solid var(--color-border);
    border-top-color: var(--color-accent);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 1rem;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .error-message {
    color: #f87171;
    margin-bottom: 0.5rem;
  }

  .error-hint {
    font-size: 0.85rem;
    text-align: center;
    max-width: 300px;
    margin-bottom: 1rem;
  }

  .view-source-btn {
    padding: 0.5rem 1rem;
    background: var(--color-accent);
    color: #000;
    border-radius: 6px;
    text-decoration: none;
    font-weight: 500;
  }

  .view-source-btn:hover {
    background: var(--color-accent-hover);
    text-decoration: none;
  }

  .viewer-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem 1rem;
    border-top: 1px solid var(--color-border);
    font-size: 0.75rem;
    color: var(--color-text-muted);
  }

  .viewer-footer p {
    margin: 0;
  }

  @media (max-width: 768px) {
    .viewer-canvas-wrapper {
      height: 300px;
    }

    .viewer-footer {
      flex-direction: column;
      gap: 0.5rem;
      text-align: center;
    }
  }
</style>
