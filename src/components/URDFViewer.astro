---
interface Props {
  urdfUrl: string;
  robotName: string;
}

const { urdfUrl, robotName } = Astro.props;
---

<div class="urdf-viewer-container" data-urdf-url={urdfUrl} data-robot-name={robotName}>
  <div class="viewer-header">
    <h3>3D Model Viewer</h3>
    <div class="viewer-controls">
      <button class="control-btn" id="reset-camera" title="Reset Camera">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
          <path d="M3 3v5h5"/>
        </svg>
      </button>
      <button class="control-btn" id="toggle-wireframe" title="Toggle Wireframe">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M12 2L2 7l10 5 10-5-10-5z"/>
          <path d="M2 17l10 5 10-5"/>
          <path d="M2 12l10 5 10-5"/>
        </svg>
      </button>
      <button class="control-btn" id="toggle-grid" title="Toggle Grid">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
          <line x1="3" y1="9" x2="21" y2="9"/>
          <line x1="3" y1="15" x2="21" y2="15"/>
          <line x1="9" y1="3" x2="9" y2="21"/>
          <line x1="15" y1="3" x2="15" y2="21"/>
        </svg>
      </button>
      <button class="control-btn" id="fullscreen-btn" title="Fullscreen">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
        </svg>
      </button>
    </div>
  </div>
  <div class="viewer-canvas-wrapper">
    <canvas id="urdf-canvas"></canvas>
    <div class="loading-overlay" id="loading-overlay">
      <div class="loader"></div>
      <p>Loading 3D model...</p>
    </div>
    <div class="error-overlay" id="error-overlay" style="display: none;">
      <p class="error-message"></p>
      <p class="error-hint">URDF files often require external mesh files that may not be accessible due to CORS restrictions.</p>
      <a href={urdfUrl} target="_blank" rel="noopener noreferrer" class="view-source-btn">View URDF Source</a>
    </div>
  </div>
  <div class="viewer-footer">
    <p>Click and drag to rotate. Scroll to zoom. Right-click to pan.</p>
    <a href={urdfUrl} target="_blank" rel="noopener noreferrer">View URDF source</a>
  </div>
</div>

<script>
  import * as THREE from 'three';
  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
  import URDFLoader from 'urdf-loader';

  class URDFViewerController {
    private container: HTMLElement;
    private canvas: HTMLCanvasElement;
    private scene: THREE.Scene;
    private camera: THREE.PerspectiveCamera;
    private renderer: THREE.WebGLRenderer;
    private controls: OrbitControls;
    private gridHelper: THREE.GridHelper;
    private robot: THREE.Group;
    private wireframeMode: boolean = false;
    private showGrid: boolean = true;
    private urdfUrl: string;

    constructor(container: HTMLElement) {
      this.container = container;
      this.canvas = container.querySelector('#urdf-canvas') as HTMLCanvasElement;
      this.urdfUrl = container.dataset.urdfUrl || '';

      if (!this.urdfUrl) {
        this.showError('No URDF URL provided');
        return;
      }

      this.init();
      this.loadRobot(this.urdfUrl);
      this.setupEventListeners();
      this.animate();
    }

    private init() {
      // Scene
      this.scene = new THREE.Scene();
      this.scene.background = new THREE.Color(0x0a0a0f);

      // Camera
      const wrapper = this.canvas.parentElement!;
      const aspect = wrapper.clientWidth / wrapper.clientHeight;
      this.camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000);
      this.camera.position.set(2, 1.5, 2);

      // Renderer
      this.renderer = new THREE.WebGLRenderer({
        canvas: this.canvas,
        antialias: true,
        alpha: true
      });
      this.renderer.setSize(wrapper.clientWidth, wrapper.clientHeight);
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      this.renderer.shadowMap.enabled = true;
      this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // Controls
      this.controls = new OrbitControls(this.camera, this.canvas);
      this.controls.enableDamping = true;
      this.controls.dampingFactor = 0.05;
      this.controls.minDistance = 0.5;
      this.controls.maxDistance = 10;

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      this.scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
      directionalLight.position.set(5, 10, 7.5);
      directionalLight.castShadow = true;
      this.scene.add(directionalLight);

      const fillLight = new THREE.DirectionalLight(0x22d3ee, 0.3);
      fillLight.position.set(-5, 3, -5);
      this.scene.add(fillLight);

      // Grid
      this.gridHelper = new THREE.GridHelper(10, 20, 0x27272a, 0x1a1a1f);
      this.scene.add(this.gridHelper);

      // Axes helper (small)
      const axesHelper = new THREE.AxesHelper(0.2);
      this.scene.add(axesHelper);

      // Handle resize
      window.addEventListener('resize', () => this.onResize());
    }

    private loadRobot(url: string) {
      const loader = new URDFLoader();
      
      // Use proxy if needed or handle CORS
      // For now, try loading directly.
      
      loader.load(
        url,
        (robot) => {
          this.robot = robot;
          
          // Center robot
          const box = new THREE.Box3().setFromObject(robot);
          const center = box.getCenter(new THREE.Vector3());
          robot.position.sub(center);
          
          // Lift up if below ground
          const minY = box.min.y - center.y;
          if (minY < 0) {
            robot.position.y -= minY;
          }

          // Enable shadows
          robot.traverse((child) => {
            if (child instanceof THREE.Mesh) {
              child.castShadow = true;
              child.receiveShadow = true;
              // Ensure generic material looks okay
              if (!child.material) {
                child.material = new THREE.MeshStandardMaterial({ color: 0x888888 });
              }
            }
          });

          this.scene.add(robot);
          this.hideLoading();
        },
        (progress) => {
          // progress handler
        },
        (error) => {
          console.error('URDF Load Error:', error);
          this.showError('Failed to load 3D model. The URDF file may be inaccessible due to CORS or the URL might be a webpage instead of a raw file.');
        }
      );
    }

    private setupEventListeners() {
      const resetBtn = this.container.querySelector('#reset-camera');
      const wireframeBtn = this.container.querySelector('#toggle-wireframe');
      const gridBtn = this.container.querySelector('#toggle-grid');
      const fullscreenBtn = this.container.querySelector('#fullscreen-btn');

      resetBtn?.addEventListener('click', () => this.resetCamera());
      wireframeBtn?.addEventListener('click', () => this.toggleWireframe());
      gridBtn?.addEventListener('click', () => this.toggleGrid());
      fullscreenBtn?.addEventListener('click', () => this.toggleFullscreen());
    }

    private resetCamera() {
      this.camera.position.set(2, 1.5, 2);
      this.controls.target.set(0, 0, 0);
      this.controls.update();
    }

    private toggleWireframe() {
      if (!this.robot) return;
      this.wireframeMode = !this.wireframeMode;
      this.robot.traverse((child) => {
        if (child instanceof THREE.Mesh) {
          if (child.material instanceof THREE.Material) {
             child.material.wireframe = this.wireframeMode;
          }
        }
      });
    }

    private toggleGrid() {
      this.showGrid = !this.showGrid;
      this.gridHelper.visible = this.showGrid;
    }

    private toggleFullscreen() {
      if (!document.fullscreenElement) {
        this.container.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    }

    private hideLoading() {
      const overlay = this.container.querySelector('#loading-overlay') as HTMLElement;
      if (overlay) {
        overlay.style.display = 'none';
      }
    }

    private showError(message: string) {
      this.hideLoading();
      
      // Hide the canvas wrapper completely to show only the error/fallback
      // Actually, we want to show the error overlay on top of the canvas
      
      const errorOverlay = this.container.querySelector('#error-overlay') as HTMLElement;
      const errorMsg = this.container.querySelector('.error-message') as HTMLElement;
      const canvas = this.container.querySelector('#urdf-canvas') as HTMLElement;
      
      if (errorOverlay && errorMsg) {
        errorMsg.textContent = message;
        errorOverlay.style.display = 'flex';
      }
      
      // If we failed completely, maybe just hide the whole viewer canvas?
      // The user said "I'd rather not show it".
      // Let's hide the canvas so we don't see an empty grid.
      if (this.scene) {
          this.scene.remove(this.gridHelper);
      }
    }

    private onResize() {
      const wrapper = this.canvas.parentElement!;
      const width = wrapper.clientWidth;
      const height = wrapper.clientHeight;

      this.camera.aspect = width / height;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(width, height);
    }

    private animate = () => {
      requestAnimationFrame(this.animate);

      if (this.robot) {
        this.robot.rotation.y += 0.001;
      }

      this.controls.update();
      this.renderer.render(this.scene, this.camera);
    };
  }

  // Initialize viewer when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    // There might be multiple viewers
    const containers = document.querySelectorAll('.urdf-viewer-container');
    containers.forEach(container => {
       new URDFViewerController(container as HTMLElement);
    });
  });
</script>

<style>
  .urdf-viewer-container {
    background: var(--color-bg-alt);
    border: 1px solid var(--color-border);
    border-radius: 12px;
    overflow: hidden;
  }

  .viewer-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem 1rem;
    border-bottom: 1px solid var(--color-border);
  }

  .viewer-header h3 {
    margin: 0;
    font-size: 0.9rem;
    font-weight: 600;
  }

  .viewer-controls {
    display: flex;
    gap: 0.5rem;
  }

  .control-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: 6px;
    color: var(--color-text-muted);
    cursor: pointer;
    transition: all 0.2s;
  }

  .control-btn:hover {
    border-color: var(--color-accent);
    color: var(--color-accent);
  }

  .viewer-canvas-wrapper {
    position: relative;
    height: 400px;
  }

  #urdf-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }

  .loading-overlay,
  .error-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(10, 10, 15, 0.9);
    color: var(--color-text-muted);
  }

  .loader {
    width: 40px;
    height: 40px;
    border: 3px solid var(--color-border);
    border-top-color: var(--color-accent);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 1rem;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .error-message {
    color: #f87171;
    margin-bottom: 0.5rem;
  }

  .error-hint {
    font-size: 0.85rem;
    text-align: center;
    max-width: 300px;
    margin-bottom: 1rem;
  }

  .view-source-btn {
    padding: 0.5rem 1rem;
    background: var(--color-accent);
    color: #000;
    border-radius: 6px;
    text-decoration: none;
    font-weight: 500;
  }

  .view-source-btn:hover {
    background: var(--color-accent-hover);
    text-decoration: none;
  }

  .viewer-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem 1rem;
    border-top: 1px solid var(--color-border);
    font-size: 0.75rem;
    color: var(--color-text-muted);
  }

  .viewer-footer p {
    margin: 0;
  }

  @media (max-width: 768px) {
    .viewer-canvas-wrapper {
      height: 300px;
    }

    .viewer-footer {
      flex-direction: column;
      gap: 0.5rem;
      text-align: center;
    }
  }
</style>
